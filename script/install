#!/usr/bin/env bash

# https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -Eueo pipefail

# =======================================================================
# = Helpers & setting some variables
# =======================================================================

DOTFILES_DIR="$HOME/.dotfiles"

if [ "$(echo "$0" | tr '[:upper:]' '[:lower:]')" == "work" ]; then
  WORK_SETUP=1
fi

tput sgr0
RED=$(tput setaf 1)
ORANGE=$(tput setaf 3)
GREEN=$(tput setaf 2)
PURPLE=$(tput setaf 5)
BLUE=$(tput setaf 4)
WHITE=$(tput setaf 7)
BOLD=$(tput bold)
RESET=$(tput sgr0)

log() {
  local LABEL="[$1]"
  local COLOR="$2"
  shift
  shift
  local MSG=("$@")
  printf "${COLOR}${LABEL}%*s${RESET}" $(($(tput cols) - ${#LABEL})) | tr ' ' '='
  for M in "${MSG[@]}"; do
    let COL=$(tput cols)-2-${#M}
    printf "%s%${COL}s${RESET}" "$COLOR* $M"
  done
  printf "${COLOR}%*s${RESET}\n\n\n" $(tput cols) | tr ' ' '='
}

log_error() {
  log "FAIL" "$RED" "$@"
  exit 1
}

log_info() {
  log "INFO" "$ORANGE" "$@"
}

log_success() {
  log "OK" "$GREEN" "$@"
}

get_permission() {
  # Ask for the administrator password upfront.
  sudo -v

  # Keep-alive: update existing `sudo` time stamp until the script has finished.
  while true; do
    sudo -n true
    sleep 60
    kill -0 "$$" || exit
  done 2>/dev/null &
}

print_main_banner() {
  cd "$HOME"
  command cat <<EOF
$BLUE
                            _       _    __ _ _
                           | |     | |  / _(_) |
                         __| | ___ | |_| |_ _| | ___  ___
                        / _. |/ _ \| __|  _| | |/ _ \/ __|
                       | (_| | (_) | |_| | | | |  __/\__ \ $()
                      (_)__,_|\___/ \__|_| |_|_|\___||___/


$RESET
EOF

  if [ -d "$DOTFILES_DIR/.git" ]; then
    command cat <<EOF
$BLUE
                      $RESET~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$BLUE
                      $RESET$BLUE
                      $RESET   $(git --git-dir "$DOTFILES_DIR/.git" --work-tree "$DOTFILES_DIR" log -n 1 --pretty=format:'%C(yellow)commit:  %h') $BLUE
                      $RESET   $(git --git-dir "$DOTFILES_DIR/.git" --work-tree "$DOTFILES_DIR" log -n 1 --pretty=format:'%C(red)date:    %ad' --date=short) $BLUE
                      $RESET   $(git --git-dir "$DOTFILES_DIR/.git" --work-tree "$DOTFILES_DIR" log -n 1 --pretty=format:'%C(cyan)author:  %an') $BLUE
                      $RESET   $(git --git-dir "$DOTFILES_DIR/.git" --work-tree "$DOTFILES_DIR" log -n 1 --pretty=format:'%C(green)message: %s') $BLUE
                      $RESET$BLUE
                      $RESET~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$BLUE
$RESET
EOF
  fi
}

print_prompt() {
  echo "What do you want to do?"
  PS3="Enter your choice (must be a number): "
  options=("All" "Install package manager" "Clone dotfiles" "Backup old files" "Symlink files" "Install Apps" "Change shell" "Quit")
  select opt in "${options[@]}"; do
    case $opt in
    "All")
      all
      break
      ;;
    "Install package manager")
      package_manager
      break
      ;;
    "Clone dotfiles")
      clone_dotfiles
      break
      ;;
    "Symlink files")
      symlink_files
      break
      ;;
    "Install Apps")
      install_apps
      break
      ;;
    "Change shell")
      get_permission
      change_shell
      break
      ;;
    "Quit")
      break
      ;;
    *)
      echo "Invalid option"
      break
      ;;
    esac
  done
}

# =======================================================================
# = Main functions
# =======================================================================

install_homebrew() {
  if ! command -v brew >/dev/null; then
    log_success "Installing Homebrew"
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    brew install stow transcrypt
  fi
}

package_manager() {
  if [ "$(uname)" == "Darwin" ]; then
    # This is handled by homebrew....?
    # if type xcode-select >&- && xpath=$( xcode-select --print-path ) && test -d "${xpath}" && test -x
    # "${xpath}"; then
    #    log_success "Command line tools are installed, moving on..."
    # else
    #   log_success "Installing Command line tools..."
    #   xcode-select --install
    # fi
    install_homebrew
  else
    # Do something linux specifc apt-get, yum, etc...
    echo "Linux package manager stuff here..."
  fi
}

decrypt_repo() {
  cd "$DOTFILES_DIR"

  echo "decrypting dotfiles..."
  echo -n "transcrypt cipher: "
  read -r cipher
  echo -n "transcrypt password: "
  read -sr password
  echo

  transcrypt -c "$cipher" -p "$password"
}

clone_dotfiles() {
  if [[ ! -d $DOTFILES_DIR ]]; then
    log_success "Cloning dotfiles..."
    git clone --recursive https://github.com/ahmedelgabri/dotfiles.git "$DOTFILES_DIR"

    # Setup repo origin & mirrors
    cd "$DOTFILES_DIR" &&
      git remote set-url origin git@github.com:ahmedelgabri/dotfiles.git &&
      git remote add --mirror=push bitbucket git@bitbucket.org:ahmedelgabri/dotfiles.git &&
      git remote add --mirror=push gitlab git@gitlab.com:ahmedelgabri/dotfiles.git

    decrypt_repo
  else
    cd "$DOTFILES_DIR" &&
      git stash -u &&
      git checkout master &&
      git reset --hard origin/master &&
      git submodule update --init --recursive &&
      git checkout - &&
      git stash pop
  fi
}

symlink_files() {
  if [[ -d $DOTFILES_DIR ]]; then
    log_success "Symlinking files/folders..."
    # I want all the make steps to run even if a cask or a brew errored out
    cd "$DOTFILES_DIR" &&
      cp files/git/.gitconfig.local $HOME/.gitconfig.local &&
      cp files/shell/.zshrc.local $HOME/.zshrc.local &&
      make initial-symlink &&
      make gpg

    if [ -n "$WORK_SETUP" ]; then
      echo "export $(hostname)_MACHINE=1" >>"$HOME/.zshrc.local"
    fi
  else
    log_error "There is no $DOTFILES_DIR directory"
  fi
}

install_apps() {
  if [[ -d $DOTFILES_DIR ]]; then
    log_success "Installing apps & tools, this will take a while..."
    if [ "$(uname)" = "Darwin" ]; then
      # I want all the make steps to run even if a cask or a brew errored out
      # So I use --ignore-errors flag
      if [ -n "$WORK_SETUP" ]; then
        cd "$DOTFILES_DIR" && make --ignore-errors homebrew-work
      else
        cd "$DOTFILES_DIR" && make --ignore-errors homebrew-personal
      fi
    else
      # install linux packages
      echo "Install Linux packages here..."
    fi
  else
    log_error "There is no $DOTFILES_DIR directory"
  fi
}

change_shell() {
  local BREW_ZSH_PATH="/usr/local/bin/zsh"

  if ! grep -q "$BREW_ZSH_PATH" /etc/shells; then
    log_success "Switching shell to zsh..."
    local ZSH_PATH=$(which zsh)

    if [ -x "$BREW_ZSH_PATH" ]; then
      ZSH_PATH="$BREW_ZSH_PATH"
    else
      log_info "Using system (outdated) zsh...."
    fi

    echo "$ZSH_PATH" | sudo tee -a /etc/shells >/dev/null
    chsh -s "$ZSH_PATH" "$(whoami)"
  else
    log_info "No need to switch shell, you are using Homebrew zsh already"
  fi
}

all() {
  get_permission
  package_manager
  clone_dotfiles
  symlink_files
  install_apps
  change_shell

  FAILED_COMMAND=$(fc -ln -1)

  if [ $? -eq 0 ]; then
    log_success "Done."
    log_info "Open a new tab & run \"cd ~/.dotfiles && make\" to install node, python packages & neovim deps" \
      "Don't forget to generate SSH keys & import gpg keys"
    command vim -u NONE $HOME/.{gitconfig,zshrc}.local
  else
    log_error "Something went wrong, [ Failed on: $FAILED_COMMAND ]"
  fi
}

run() {
  print_main_banner
  print_prompt
}

# =======================================================================
# = Run!
# =======================================================================

run
